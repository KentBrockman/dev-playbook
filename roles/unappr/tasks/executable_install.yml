# The interface for binary installs is slightly different
# There is no predefined provider here
# This interface is a 'last resort' designed to address
# the case where the app you're trying to get is not
# available through the other package managers
#
# You need to provide:
# - url to download from, presumably with a version
# Optionally:
# - exec_name, which may differ from app name e.g. minioclient vs mc
---
- name: Set executable and metadata paths
  set_fact:
    executable_path: "{{ executable_directory }}/{{ app.exec_name | default(app.name) }}"
    executable_metadata: "{{ executable_directory }}/.{{ app.exec_name | default(app.name) }}.metadata"

- name: Get url from metadata
  # command: "cat {{ executable_metadata }}"
  # TODO: how to get this from target
  shell: if [ ! -f '"{{ executable_metadata }}"' ]; then touch "{{ executable_metadata }}"; fi; "cat {{ executable_metadata }};"
  changed_when: false
  register: current_url_output

- name: get current url
  set_fact:
    current_url: current_url_output.stdout

- name: download executable
  get_url:
    url: "{{ app.url }}"
    dest: "{{ executable_path }}"
    mode: "+x"
    # force a redownload when url from metadata doesn't match what is provided to this role
    force: "{{ current_url != app.url }}"
  # when url does not end in .zip
  when: app.url | regex_search(".*(?<!zip)$")

- name: download and unzip executable
  unarchive:
    url: "{{ app.url }}"
    dest: "{{ executable_directory }}"
    mode: "+x"
  # when url ends in .zip
  when: app.url | regex_search('.*zip$') and current_url != app.url

- name: write app.url to metadata
  copy:
    content: "{{ app.url }}"
    dest: "{{ executable_metadata }}"
  when: current_url != app.url
